<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor Avanzado de Colecciones Pokémon TCG con Firebase</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Estilos personalizados -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .card-container { position: relative; transition: transform 0.3s ease-in-out; }
        .card-container:hover { transform: scale(1.05); }
        .card-image { transition: box-shadow 0.3s ease-in-out; }
        .card-container:hover .card-image { box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2); }
        
        .in-any-collection .card-image { box-shadow: 0 0 15px 5px rgba(59, 130, 246, 0.7); border: 2px solid #3B82F6; }
        .is-owned .card-image { box-shadow: 0 0 15px 5px rgba(234, 179, 8, 0.7); border: 2px solid #ca8a04; }

        .card-btn { position: absolute; width: 32px; height: 32px; border-radius: 50%; background-color: rgba(0, 0, 0, 0.6); color: white; display: flex; justify-content: center; align-items: center; font-size: 20px; font-weight: bold; border: 2px solid white; cursor: pointer; transition: background-color 0.2s, transform 0.2s; z-index: 10; }
        .card-btn:hover { transform: scale(1.1); }
        
        .manage-card-btn { top: 8px; right: 8px; }
        .manage-card-btn.in-any-collection { background-color: #3B82F6; }
        
        .owned-toggle-btn { top: 8px; left: 8px; }
        .owned-toggle-btn.is-owned { background-color: #16a34a; }

        :disabled { background-color: #e9ecef; cursor: not-allowed; }

        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 40; }
        .modal-content { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 50; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">Gestor de Colecciones Pokémon</h1>
            <p class="text-gray-600 mt-2">Busca cartas y organízalas en tus propias colecciones.</p>
        </header>

        <div class="bg-white p-6 rounded-2xl shadow-lg mb-8">
            <div class="mb-6 text-center border-b pb-6">
                 <h2 class="text-lg font-semibold text-gray-800">Mis Colecciones</h2>
                 <p id="auth-status" class="text-sm text-red-500 font-semibold mt-1">Por favor, inicia sesión para gestionar tus colecciones.</p>
                 <button id="manageCollectionsBtn" class="mt-2 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg" disabled>Gestionar Mis Colecciones</button>
            </div>

            <!-- Contenedor de Filtros con Posesión primero -->
            <div id="filtersContainer" class="grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
                <div>
                    <label for="ownedFilter" class="block text-sm font-medium text-gray-700">Posesión</label>
                    <select id="ownedFilter" class="mt-1 w-full p-3 border border-gray-300 rounded-lg bg-white" disabled>
                        <option value="all">Todas</option>
                        <option value="owned">Obtenidas</option>
                        <option value="unowned">No Obtenidas</option>
                    </select>
                </div>
                <div>
                    <label for="pokemonName" class="block text-sm font-medium text-gray-700">Nombre</label>
                    <input type="text" id="pokemonName" class="mt-1 w-full p-3 border border-gray-300 rounded-lg" placeholder="Ej: Pikachu" disabled>
                </div>
                <div>
                    <label for="pokemonType" class="block text-sm font-medium text-gray-700">Tipo</label>
                    <select id="pokemonType" class="mt-1 w-full p-3 border border-gray-300 rounded-lg bg-white" disabled> <option value="">Cualquiera</option> </select>
                </div>
                <div>
                    <label for="collectionFilter" class="block text-sm font-medium text-gray-700">Colección</label>
                    <select id="collectionFilter" class="mt-1 w-full p-3 border border-gray-300 rounded-lg bg-white" disabled> <option value="all">Todas</option> </select>
                </div>
            </div>
        </div>

        <div id="status" class="text-center my-8"><div id="loader" class="loader mx-auto hidden"></div><p id="message" class="text-gray-600 text-lg"></p></div>
        <main id="results" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6"></main>
    </div>

    <!-- Modales (sin cambios) -->
    <div id="manageCollectionsModal" class="modal-backdrop hidden">
        <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-11/12 md:w-1/3">
            <h3 class="text-xl font-bold mb-4">Gestionar Mis Colecciones</h3>
            <div id="collectionsList" class="mb-4 max-h-60 overflow-y-auto"></div>
            <div class="flex gap-2">
                <input type="text" id="newCollectionName" placeholder="Nombre de la nueva colección" class="flex-grow p-2 border rounded-lg">
                <button id="addCollectionBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600">Añadir</button>
            </div>
            <button id="closeManageCollectionsModal" class="mt-4 w-full bg-gray-500 text-white p-2 rounded-lg hover:bg-gray-600">Cerrar</button>
        </div>
    </div>
    <div id="assignCardModal" class="modal-backdrop hidden">
         <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-11/12 md:w-1/3">
            <h3 class="text-xl font-bold mb-4">Asignar Carta a...</h3>
            <div id="assignCollectionsList" class="mb-4 max-h-60 overflow-y-auto"></div>
            <div class="flex gap-4">
                <button id="saveCardAssignmentBtn" class="flex-grow bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600">Guardar</button>
                <button id="closeAssignCardModal" class="flex-grow bg-gray-500 text-white p-2 rounded-lg hover:bg-gray-600">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- SDK de Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, arrayUnion, arrayRemove, writeBatch } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBy9NGyELQsS-t59D93EM4geWBwBr56O08",
            authDomain: "pokesnixx.firebaseapp.com",
            projectId: "pokesnixx",
            storageBucket: "pokesnixx.appspot.com",
            messagingSenderId: "226747705445",
            appId: "1:226747705445:web:9c9d5d858c52a9c8e13e8c",
            measurementId: "G-EX07BC6EX4"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        let currentUser = null;
        let userCustomCollections = [];
        let cardAssignments = {};
        let userOwnedCards = new Set();
        let unsubscribes = [];
        let searchDebounceTimeout;

        const dom = {
            authStatus: document.getElementById('auth-status'),
            manageCollectionsBtn: document.getElementById('manageCollectionsBtn'),
            pokemonName: document.getElementById('pokemonName'),
            pokemonType: document.getElementById('pokemonType'),
            collectionFilter: document.getElementById('collectionFilter'),
            ownedFilter: document.getElementById('ownedFilter'),
            results: document.getElementById('results'),
            message: document.getElementById('message'),
            loader: document.getElementById('loader'),
            manageCollectionsModal: document.getElementById('manageCollectionsModal'),
            collectionsList: document.getElementById('collectionsList'),
            newCollectionName: document.getElementById('newCollectionName'),
            addCollectionBtn: document.getElementById('addCollectionBtn'),
            closeManageCollectionsModal: document.getElementById('closeManageCollectionsModal'),
            assignCardModal: document.getElementById('assignCardModal'),
            assignCollectionsList: document.getElementById('assignCollectionsList'),
            saveCardAssignmentBtn: document.getElementById('saveCardAssignmentBtn'),
            closeAssignCardModal: document.getElementById('closeAssignCardModal')
        };
        
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                dom.authStatus.textContent = `Sesión iniciada: ${user.displayName || user.email}`;
                dom.authStatus.classList.replace('text-red-500', 'text-green-600');
                enableApp();
                listenToUserData();
            } else {
                currentUser = null;
                dom.authStatus.textContent = 'Inicia sesión para gestionar tus colecciones.';
                dom.authStatus.classList.replace('text-green-600', 'text-red-500');
                disableApp();
                unsubscribes.forEach(unsub => unsub());
            }
        });

        function listenToUserData() {
            if (!currentUser) return;
            unsubscribes.forEach(unsub => unsub());
            unsubscribes = [];

            const customCollectionsRef = doc(db, 'users', currentUser.uid, 'collections', 'metadata');
            unsubscribes.push(onSnapshot(customCollectionsRef, (docSnap) => {
                userCustomCollections = docSnap.exists() ? docSnap.data().list || [] : [];
                populateCollectionFilter();
                updateDisplayedCardsState();
            }));

            const assignmentsRef = doc(db, 'users', currentUser.uid, 'cards', 'assignments');
            unsubscribes.push(onSnapshot(assignmentsRef, (docSnap) => {
                cardAssignments = docSnap.exists() ? docSnap.data() : {};
                updateDisplayedCardsState();
            }));

            const ownedRef = doc(db, 'users', currentUser.uid, 'cards', 'owned');
            unsubscribes.push(onSnapshot(ownedRef, (docSnap) => {
                const wasEmpty = userOwnedCards.size === 0;
                userOwnedCards = docSnap.exists() ? new Set(docSnap.data().ids || []) : new Set();
                
                // Si la lista de obtenidas estaba vacía y ahora tiene cartas, y estamos en el filtro "obtenidas",
                // refrescamos la búsqueda para mostrar las cartas.
                if (wasEmpty && userOwnedCards.size > 0 && dom.ownedFilter.value === 'owned') {
                    triggerSearch();
                }
                updateDisplayedCardsState();
            }));
        }
        
        async function fetchAndDisplayCards(url) {
            if (!currentUser) return;
            const apiKey = "0b793f15-1998-48e4-9cc4-0a9e1b5badf6";
            if (!apiKey) {
                dom.message.textContent = 'Falta la clave API de Pokémon TCG.';
                return;
            }

            dom.results.innerHTML = '';
            dom.message.textContent = 'Cargando cartas...';
            dom.loader.classList.remove('hidden');

            try {
                const response = await fetch(url, { headers: { 'X-Api-Key': apiKey } });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error.message || 'Error en la API.');
                }
                const data = await response.json();
                dom.loader.classList.add('hidden');
                dom.message.textContent = '';

                if (data.data && data.data.length > 0) {
                    displayCards(data.data);
                } else {
                    dom.message.textContent = 'No se encontraron cartas que coincidan con los criterios.';
                }
            } catch (error) {
                console.error('Error durante la búsqueda:', error);
                dom.loader.classList.add('hidden');
                dom.message.textContent = `Ocurrió un error: ${error.message}`;
            }
        }

        const debouncedTriggerSearch = () => {
             clearTimeout(searchDebounceTimeout);
             searchDebounceTimeout = setTimeout(triggerSearch, 500);
        }
        
        function triggerSearch() {
            const ownedFilterValue = dom.ownedFilter.value;
            const nameQuery = dom.pokemonName.value.trim();
            const typeQuery = dom.pokemonType.value;
            const API_BASE_URL = 'https://api.pokemontcg.io/v2';
            let queryParts = [];

            if (nameQuery) queryParts.push(`name:${nameQuery}*`);
            if (typeQuery) queryParts.push(`types:${typeQuery}`);
            
            if (ownedFilterValue === 'owned') {
                if (userOwnedCards.size === 0) {
                    dom.results.innerHTML = '';
                    dom.message.textContent = 'No tienes ninguna carta marcada como "Obtenida".';
                    dom.loader.classList.add('hidden');
                    return;
                }
                const idQuery = `(${Array.from(userOwnedCards).map(id => `id:${id}`).join(' OR ')})`;
                queryParts.push(idQuery);
            }

            let url;
            if (queryParts.length === 0) {
                url = `${API_BASE_URL}/cards?orderBy=name&pageSize=100`;
            } else {
                const query = queryParts.join(' ');
                url = `${API_BASE_URL}/cards?q=${encodeURIComponent(query)}&orderBy=name&pageSize=100`;
            }
            
            fetchAndDisplayCards(url);
        }

        dom.pokemonName.addEventListener('input', debouncedTriggerSearch);
        dom.pokemonType.addEventListener('change', triggerSearch);
        dom.ownedFilter.addEventListener('change', triggerSearch);
        
        async function toggleOwnedStatus(cardId) {
            if (!currentUser) return;
            const ownedRef = doc(db, 'users', currentUser.uid, 'cards', 'owned');
            if (userOwnedCards.has(cardId)) {
                await setDoc(ownedRef, { ids: arrayRemove(cardId) }, { merge: true });
            } else {
                await setDoc(ownedRef, { ids: arrayUnion(cardId) }, { merge: true });
            }
        }
        
        dom.collectionFilter.addEventListener('change', applyAllFilters);

        function applyAllFilters() {
            const collectionFilterValue = dom.collectionFilter.value;
            const ownedFilterValue = dom.ownedFilter.value;
            const allCards = dom.results.querySelectorAll('.card-container');

            allCards.forEach(cardEl => {
                const cardId = cardEl.dataset.cardId;
                
                const cardColls = cardAssignments[cardId] || [];
                const isInCollection = (collectionFilterValue === 'all' || cardColls.includes(collectionFilterValue));
                
                let isVisible = isInCollection;

                // El filtro de posesión para "obtenidas" se maneja a nivel de API.
                // Aquí solo manejamos el caso "no obtenidas" de forma visual.
                if (ownedFilterValue === 'unowned' && userOwnedCards.has(cardId)) {
                    isVisible = false;
                }

                cardEl.classList.toggle('hidden', !isVisible);
            });
        }

        function displayCards(cards) {
            dom.results.innerHTML = '';
            cards.forEach(card => {
                const cardContainer = document.createElement('div');
                cardContainer.className = 'card-container';
                cardContainer.dataset.cardId = card.id;

                const cardImage = document.createElement('img');
                cardImage.src = card.images.small;
                cardImage.className = 'rounded-lg shadow-md card-image w-full';

                const manageBtn = document.createElement('button');
                manageBtn.className = 'card-btn manage-card-btn';
                manageBtn.innerHTML = '...';
                manageBtn.onclick = () => openCardAssignmentModal(card.id);

                const ownedBtn = document.createElement('button');
                ownedBtn.className = 'card-btn owned-toggle-btn';
                ownedBtn.onclick = () => toggleOwnedStatus(card.id);
                
                cardContainer.append(ownedBtn, manageBtn, cardImage);
                dom.results.append(cardContainer);
            });
            updateDisplayedCardsState();
        }

        function updateDisplayedCardsState() {
            const allCards = dom.results.querySelectorAll('.card-container');
            allCards.forEach(cardEl => {
                const cardId = cardEl.dataset.cardId;

                const isInAny = cardAssignments[cardId] && cardAssignments[cardId].length > 0;
                cardEl.classList.toggle('in-any-collection', isInAny);
                cardEl.querySelector('.manage-card-btn').classList.toggle('in-any-collection', isInAny);

                const isOwned = userOwnedCards.has(cardId);
                cardEl.classList.toggle('is-owned', isOwned);
                const ownedBtn = cardEl.querySelector('.owned-toggle-btn');
                ownedBtn.classList.toggle('is-owned', isOwned);
                ownedBtn.innerHTML = isOwned ? '&#10003;' : '';
            });
            applyAllFilters();
        }
        
        function enableApp() {
            Object.values(dom).forEach(el => {
                if (el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'BUTTON') {
                    el.disabled = false;
                }
            });
            dom.ownedFilter.value = 'all';
            loadDropdownFilters();
            triggerSearch();
        }

        function disableApp() {
             Object.values(dom).forEach(el => {
                if (el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'BUTTON') {
                    el.disabled = true;
                }
            });
            dom.results.innerHTML = '';
            dom.message.textContent = '';
            userCustomCollections = [];
            cardAssignments = {};
            userOwnedCards.clear();
        }

        async function loadDropdownFilters() { 
            const API_BASE_URL = 'https://api.pokemontcg.io/v2';
            const apiKey = "0b793f15-1998-48e4-9cc4-0a9e1b5badf6"; 
            if (!apiKey) { return; }

            try {
                const response = await fetch(`${API_BASE_URL}/types`, { headers: { 'X-Api-Key': apiKey } });
                if(!response.ok) return;
                const data = await response.json();
                
                const typeSelect = document.getElementById('pokemonType');
                while (typeSelect.options.length > 1) {
                    typeSelect.remove(1);
                }
                data.data.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    typeSelect.appendChild(option);
                });
            } catch(error) {
                console.error("Error al cargar los tipos de Pokémon:", error);
            }
        }
                
        function populateCollectionFilter() {
            const currentSelection = dom.collectionFilter.value;
            dom.collectionFilter.innerHTML = '<option value="all">Todas</option>';
            userCustomCollections.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                dom.collectionFilter.appendChild(option);
            });
            if (document.querySelector(`#collectionFilter option[value='${currentSelection}']`)) {
                 dom.collectionFilter.value = currentSelection;
            }
        }

        // El resto de funciones para gestionar modales y colecciones se mantienen igual
        dom.manageCollectionsBtn.addEventListener('click', () => {
            populateCollectionsManager();
            dom.manageCollectionsModal.classList.remove('hidden');
        });
        dom.closeManageCollectionsModal.addEventListener('click', () => dom.manageCollectionsModal.classList.add('hidden'));
        dom.addCollectionBtn.addEventListener('click', async () => {
            const name = dom.newCollectionName.value.trim();
            if (name && !userCustomCollections.includes(name)) {
                const ref = doc(db, 'users', currentUser.uid, 'collections', 'metadata');
                await setDoc(ref, { list: arrayUnion(name) }, { merge: true });
                dom.newCollectionName.value = '';
                populateCollectionsManager();
            }
        });
        function populateCollectionsManager() {
            dom.collectionsList.innerHTML = '';
            userCustomCollections.forEach(name => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center p-2 border-b';
                div.textContent = name;
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Eliminar';
                deleteBtn.className = 'bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600';
                deleteBtn.onclick = () => deleteCollection(name);
                div.appendChild(deleteBtn);
                dom.collectionsList.appendChild(div);
            });
        }
        async function deleteCollection(name) {
            if (!confirm(`¿Seguro que quieres eliminar la colección "${name}"? Esta acción no se puede deshacer.`)) return;
            const batch = writeBatch(db);
            const metadataRef = doc(db, 'users', currentUser.uid, 'collections', 'metadata');
            batch.update(metadataRef, { list: arrayRemove(name) });
            const assignmentsRef = doc(db, 'users', currentUser.uid, 'cards', 'assignments');
            const updatedAssignments = { ...cardAssignments };
            Object.keys(updatedAssignments).forEach(cardId => {
                const assignments = updatedAssignments[cardId];
                if (assignments) {
                    const index = assignments.indexOf(name);
                    if (index > -1) {
                        assignments.splice(index, 1);
                    }
                }
            });
            batch.set(assignmentsRef, updatedAssignments);
            await batch.commit();
            populateCollectionsManager();
        }
        dom.closeAssignCardModal.addEventListener('click', () => dom.assignCardModal.classList.add('hidden'));
        dom.saveCardAssignmentBtn.addEventListener('click', async () => {
            const cardId = dom.saveCardAssignmentBtn.dataset.cardId;
            const selectedCollections = [];
            dom.assignCollectionsList.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
                selectedCollections.push(checkbox.value);
            });
            const assignmentsRef = doc(db, 'users', currentUser.uid, 'cards', 'assignments');
            await setDoc(assignmentsRef, { [cardId]: selectedCollections }, { merge: true });
            dom.assignCardModal.classList.add('hidden');
        });
        function openCardAssignmentModal(cardId) {
            dom.saveCardAssignmentBtn.dataset.cardId = cardId;
            dom.assignCollectionsList.innerHTML = '';
            const currentAssignments = cardAssignments[cardId] || [];
            userCustomCollections.forEach(name => {
                const div = document.createElement('div');
                div.className = 'flex items-center mb-2';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `chk-${name}-${cardId}`;
                checkbox.value = name;
                checkbox.checked = currentAssignments.includes(name);
                checkbox.className = 'h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500';
                const label = document.createElement('label');
                label.htmlFor = `chk-${name}-${cardId}`;
                label.textContent = name;
                label.className = 'ml-2 block text-sm text-gray-900';
                div.append(checkbox, label);
                dom.assignCollectionsList.appendChild(div);
            });
            dom.assignCardModal.classList.remove('hidden');
        }

    </script>
</body>
</html>
